<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Visualizing Real-Time Point-Cloud Sound Intensity Data via Voronoi Tesselation</title>
<meta property='og:title' content="Visualizing Real-Time Point-Cloud Sound Intensity Data via Voronoi Tesselation">
<meta property="og:description" content="Here's a prototype of our sound field viz server, working with simulated data for room mode measurements." />
<meta property="og:image" content="http://hedges.belmont.edu/~shawley/voronoi.png">
<meta property="og:url" content="http://hedges.belmont.edu/~shawley/d3-voronoi-demo.html">
<style>


.polygons {
  fill: none;
  stroke: #000;
}


.sites {
  fill: #000;
  stroke: #fff;
}

.dropdown{
    display: inline;
}

</style>
</head>
<body>


<h2>Visualizing Real-Time Point-Cloud Sound Intensity Data via Voronoi Tesselation</h2>
This is for the Google Tango app project, which uses a client-server model whereby the Tango ("client")
sends its measurements via WebSockets to this vizualization server.<br>
Here's a prototype of our sound viz server.<br>
You can pan and zoom. Yay!<br>
This works best with the Chrome browser; Firefox is slow.<br>
<br>


<button id="reset">Reset Zoom</button>
<button id="sitesToggle">Toggle Sites</button>
<button id="boundsToggle">Toggle Boundaries</button>

Filter frequency:
<div class="dropdown"
  <form>
       <select id="freqDropDown" onchange="freqChange(this)" >
          <option value="0" selected="selected"> Param EQ</option>
          <option value="1"> 62.5 Hz</option>
          <option value="2"> 125 Hz</option>
          <option value="3"> 250 Hz</option>
          <option value="4"> 500 Hz</option>
          <option value="5">1000 Hz</option>
          <option value="6">2000 Hz</option>
          <option value="7">4000 Hz</option>
      </select>
  </form>
</div>
<button id="clear">Erase Data</button>


 <br>
<svg width="500" height="500"></svg>
<textarea rows="10" cols="40">
Notes:

</textarea>


<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  //----------------------- WebSocket Handling
  $(function () {
    var socket = io();
    $('form').submit(function(){
      socket.emit('chat message', $('#m').val());
      $('#m').val('');
      return false;
    });
    socket.on('chat message', function(msg){   // We got a message!
      //$('#messages').append($('<li>').text(msg));
      applyNewMsg(msg);
    });
  });



  //----------------------    Graph Handling

    var margin = {top: 20, right: 20, bottom: 30, left: 40},
      width = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;


    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    var colorBar = d3.select("body")
            .append("svg")

    var zoom = d3.zoom()
        .scaleExtent([.5, 40])
        .translateExtent([[-100, -100], [width + 90, height + 100]])
        .on("zoom", zoomed);


    transform = d3.zoomIdentity;

    // Random data to start with
    var npoints = 1500;
    var sites = d3.range(npoints)
        .map(function(d) { return [Math.random() * width, Math.random() * height]; });


    // values  at data points / colors being mapped = "dBvals"

    // demo data:
    nZBins = 8;
    var dBvals = [ d3.range(npoints), d3.range(npoints), d3.range(npoints), d3.range(npoints),
                   d3.range(npoints), d3.range(npoints), d3.range(npoints), d3.range(npoints)];
   /*
   // fake room modes
   var kx = 3.14159/(width);
   var ky = 3.14159/(height);
    for (j = 0; j < nZBins; j++) {
      for (i = 0; i < npoints; i++) {
          dBvals[j][i] = (1.0 + Math.cos((j+1)*kx*sites[i][0]) * Math.cos((j+1)*ky*sites[i][1]))/2.0;
          dBvals[j][i] *= dBvals[j][i];
      }
    }
    */
    // fake two-speaker interference pattern
    var ppf = 50;    // pixels per foot
    var vs = 1130;    // feet per second
    var dist = 2*ppf;    // sources 2 feet apart
    var source1x = width/2 - dist/2;
    var source2x = width/2 + dist/2;
    var source1y = height;
    var source2y = source1y;
     for (j = 0; j < nZBins; j++) {
       var f =  32.25*Math.pow(2, j);
       var lambda = vs/f * ppf;
       var k = 2*3.1415/lambda;
       for (i = 0; i < npoints; i++) {
           var r1 = Math.sqrt( (sites[i][0] - source1x)**2 + (sites[i][1]-source1y)**2 );
           var r2 = Math.sqrt( (sites[i][0] - source2x)**2 + (sites[i][1]-source2y)**2 );
           dBvals[j][i] = Math.cos(k*r1)/r1 + Math.cos(k*r2)/r2;

           dBvals[j][i] *= dBvals[j][i];
           dBvals[j][i] = 2*Math.log(dBvals[j][i])
       }
     }
     var dBIndex = document.getElementById("freqDropDown").value;
     dB_plot = dBvals[dBIndex];
     dBMax = Math.max.apply(Math, dB_plot);
     dBMin = Math.min.apply(Math,  dB_plot);
     console.log("dBMin =",dBMin,", dBMax =",dBMax);
     colors = dB_plot.map(function(q) { return q - dBMin; });

     colorMax = Math.max.apply(Math, colors);
     colorMin = Math.min.apply(Math, colors);
     console.log("colorMin = ",colorMin,", colorMax = ",colorMax)
     intendedColorRange = 310;
     colorScaleFactor = intendedColorRange/(colorMax - colorMin);


    //  End demo data

    var showSites = true;
    var showBounds = true;

    var g = svg.append("g")
        .attr("transform", "translate(" + 0+ "," + 0 + ")");


    function getMinMaxOf2DIndex (arr, idx) { //https://stackoverflow.com/questions/23396945/getting-the-min-and-max-value-in-javascript-but-from-a-2d-array
        return {
            min: Math.min.apply(null, arr.map(function (e) { return e[idx]})),
            max: Math.max.apply(null, arr.map(function (e) { return e[idx]}))
        }
    }

    var xextents = getMinMaxOf2DIndex(sites,0);
    var yextents = getMinMaxOf2DIndex(sites,1);
    console.log("xextents.min = ",xextents.min)
    var voronoi = d3.voronoi()
        .extent([[xextents.min-1, yextents.min-1], [xextents.max + 1, yextents.max + 1]]);


    var polygon = svg.append("g")
        .attr("class", "polygons")
        .selectAll("path")
        .data(voronoi.polygons(sites))
        .enter().append("path")
        .style('fill', function(d,i){ return d3.hsl( colors[i]*colorScaleFactor + colorMin,        1, .5); })
        .call(redrawPolygon);

    var site = svg.append("g")
    .attr("class", "sites")
    .selectAll("circle")
    .data(sites)
    .enter().append("circle")
    .attr("r", 2.5)
    .call(redrawSite);

    function redrawPolygon(polygon) {
      polygon
          .attr("d", function(d) { return d ? "M" + d.join("L") + "Z" : null; });
    }
    function redrawSite(site) {
      site
      .attr("cx", function(d) { return d[0]; })
      .attr("cy", function(d) { return d[1]; });
    }


    // Buttons
    d3.select("#reset").on("click", reset_zoom);
    d3.select("#clear").on("click", clear_data);
    d3.select("#sitesToggle").on("click", function (d) {
        showSites = !showSites;
        if (false==showSites) {
            svg.selectAll("g.sites").style('fill','none');
            svg.selectAll("g.sites").style('stroke','none');
        } else {
            svg.selectAll("g.sites").style('fill','#000');
            svg.selectAll("g.sites").style('stroke','#fff');
        }
    });
    d3.select("#boundsToggle").on("click", function (d) {
        showBounds = !showBounds;
        if (false==showBounds) {
            svg.selectAll("g.polygons").style('stroke', 'none');
        } else {
            svg.selectAll("g.polygons").style('stroke', '#000');
        }
    });


    // Zooming
    svg.call(zoom);

    function zoomed() {
        transform = d3.event.transform;
        effect_zoom(transform);

    }
    function effect_zoom(transform) {
        site.attr("transform", transform);
        polygon.attr("transform", transform);
    }

    function reset_zoom() {
      svg.transition()
          .duration(700)
          .call(zoom.transform, d3.zoomIdentity);
      transform = d3.zoomIdentity;
    }
    function clear_data() {
      svg.selectAll("g.polygons").remove(); // delete old polygons
      svg.selectAll("g.sites").remove(); // delete old sites
    }


    // Freq Change
    function freqChange(option) {
        //console.log(option.value);
        //basefreq = 250.0;
        //freq = option.value*1.0
        freqBin = option.value;
        var dBIndex = document.getElementById("freqDropDown").value;

        dB_plot = dBvals[dBIndex];
        dBMax = Math.max.apply(Math, dB_plot);
        dBMin = Math.min.apply(Math,  dB_plot);
        console.log("dBMin =",dBMin,", dBMax =",dBMax);
        colors = dB_plot.map(function(q) { return q - dBMin; });

        colorMax = Math.max.apply(Math, colors);
        colorMin = Math.min.apply(Math, colors);
        console.log("colorMin = ",colorMin,", colorMax = ",colorMax)


        colorScaleFactor = intendedColorRange/(colorMax - colorMin) + colorMin;
        /*
        kx = 2.0*3.14159/(width*0.5)* (freq/basefreq);
        ky = 2.0*3.14159/(height*0.5)*(freq/basefreq);
        for (i = 0; i < npoints; i++) {
            dBvals[0][i] = (1.0 + Math.cos(kx*sites[i][0]) * Math.cos(ky*sites[i][1]))/2.0;
            dBvals[0][i] *= dBvals[0][i];
        }*/
        svg.selectAll("g.polygons")
        .selectAll("path")
          .style('fill', function(d,i){ return d3.hsl( colors[i]*colorScaleFactor + colorMin,        1, .5); })
            .call(redrawPolygon);
        if (false == showBounds) {
            svg.selectAll("g.polygons").style('stroke', 'none');
        }
        //redrawSite();
    }



    // When new socket messages come in
    function parseMsg(msg) {

        /* var msg = `x,y,z,dB
0.029991373,-0.039875697,-0.115854755,-41
0.03036066,-0.039075352,-0.11549742,-41
0.03096545,-0.03815586,-0.11500641,-41
0.031788256,-0.037278954,-0.11437142,-41
0.03286398,-0.036341358,-0.113565676,-41`;*/
        // https://stackoverflow.com/questions/41154231/d3-how-do-i-parse-a-csv-string-into-an-object-where-keys-are-column-names-and-v
        //console.log("parseMsg: msg = ",msg);
        var data = d3.csvParse(msg);
        var headers = d3.keys(data[0]);
        console.log("headers = ",headers)

        var myObject = {};
        headers.forEach(function(d) {
            myObject[d] = [];
        });
        data.forEach(function(d) {
            for (var key in d) {
                myObject[key].push(d[key]);
            }
        });
        //console.log("myObject = ",myObject)
        return myObject;
    }



    function applyNewMsg(msg) {
        //console.log("Message received: ",msg);
        var parsed = parseMsg(msg);
        var x = parsed.x;
        //console.log("x =  ",x);

        var y = parsed.y;
        var z = parsed.z;
        var dB = parsed.dB;    // Fullband-averaged dB value
        var dB0 = parsed.dB0;  // dB in lowest freq band (63Hz)
        var dB1 = parsed.dB1;  // dB in next freq band (125Hz)
        var dB2 = parsed.dB2;  // dB in next freq band (250Hz)
        var dB3 = parsed.dB3;  // dB in next freq band (500Hz)
        var dB4 = parsed.dB4;  // dB in next freq band (1kHz)
        var dB5 = parsed.dB5;  // dB in next freq band (2kHz)
        var dB6 = parsed.dB6;  // dB in next freq band (4kHz)

        updateData(x,y,z,dB,dB0,dB1,dB2,dB3,dB4,dB5,dB6);
    }




    function updateData(x,y,z,dB,dB0,dB1,dB2,dB3,dB4,dB5,dB6) {
        // note: z never gets used. we use dB to do the coloring.

        npoints = x.length;
        /*console.log("npoints = ",npoints);
        //console.log("x = ",x);
        //console.log("y = ",y);
        //console.log("dB = ",dB);*/
        x = x.map(Number);
        y = y.map(Number);
        dBvals[0] = dB.map(Number);
        dBvals[1] = dB0.map(Number);
        dBvals[2] = dB1.map(Number);
        dBvals[3] = dB2.map(Number);
        dBvals[4] = dB3.map(Number);
        dBvals[5] = dB4.map(Number);
        dBvals[6] = dB5.map(Number);
        dBvals[7] = dB6.map(Number);


        var dBIndex = document.getElementById("freqDropDown").value;
        //console.log("Dropdown index = ",dBIndex);

        //scale world coordinates to screen coordinates
        xMin = Math.min.apply(Math, x);
        xMax = Math.max.apply(Math, x);
        yMin = Math.min.apply(Math, y);
        yMax = Math.max.apply(Math, y);

        xScale = width / (xMax-xMin);
        yScale = height / (yMax-yMin);
        uniScale = xScale;   // use the same (smaller) scale in x & y
        if (yScale < xScale) {
          uniScale = yScale;
        }
        xScreen = x.map(function(q) { return (q - xMin) * uniScale; });
        yScreen = y.map(function(q) { return (q - yMin) * uniScale; });

        sites = d3.range(npoints)
         .map(function(d,i) { return [(xScreen[i]), (yScreen[i])]; });




        // scale dB -> color
        dB_plot = dBvals[dBIndex];
        dBMax = Math.max.apply(Math, dB_plot);
        dBMin = Math.min.apply(Math,  dB_plot);
        //console.log("dBMin =",dBMin,", dBMax =",dBMax);
        colors = dB_plot.map(function(q) { return q - dBMin; });

        colorMax = Math.max.apply(Math, colors);
        colorMin = Math.min.apply(Math, colors);
        intendedColorRange = 310;
        colorScaleFactor = intendedColorRange/(colorMax - colorMin);
        //console.log("colors[0] = ",colors[0]);
        //console.log("colorScaleFactor = ",colorScaleFactor);

        //console.log("colorMin =",colorMin,", colorMax =",colorMax);


        var xextents = getMinMaxOf2DIndex(sites,0);
        var yextents = getMinMaxOf2DIndex(sites,1);
        console.log("xextents.min = ",xextents.min)
        var voronoi = d3.voronoi()
            .extent([[xextents.min-1, yextents.min-1], [xextents.max + 1, yextents.max + 1]]);

        svg.selectAll("g.polygons").remove(); // delete old polygons
        polygon = svg.append("g")             // add new polygons
          .attr("class", "polygons")
        .selectAll("path")
        .data(voronoi.polygons(sites))
        .enter().append("path")
        .style('fill', function(d,i){ return d3.hsl( colors[i]*colorScaleFactor + colorMin,        1, .5); })
          .call(redrawPolygon);
        if (false == showBounds) {
          svg.selectAll("g.polygons").style('stroke', 'none');
        }

        svg.selectAll("g.sites").remove();  // delete old sites
        site = svg.append("g")              // add new sites
        .attr("class", "sites")
        .selectAll("circle")
        .data(sites)
        .enter().append("circle")
        .attr("r", 2.5)
        .call(redrawSite);

        if (false==showSites) {
          svg.selectAll("g.sites").style('fill','none');
          svg.selectAll("g.sites").style('stroke','none');
        }
        effect_zoom(transform);
    }

    // from http://techslides.com/demos/d3/svg-to-image-1.html



</script>

</body>
</html>
