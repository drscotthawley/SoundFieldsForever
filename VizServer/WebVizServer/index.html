<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SFF WebViz</title>
<meta property='og:title' content="Sounds Fields Forever WebViz Server">
<meta property="og:description" content="This is the server that takes data from the Tango client and plots it." />
<meta property="og:image" content="http://hedges.belmont.edu/~shawley/WebVizServer/sffwebviz.png">
<meta property="og:url" content="http://hedges.belmont.edu/~shawley/WebVizServer">
<style>
 

.polygons {
  fill: none;
  stroke: #000;
}


.sites {
  fill: #000;
  stroke: #fff;
}

.dropdown{
    display: inline;
}

.button {
}

</style>
</head>
<body>


<h2>Sound Fields Forever: Visualization Server</h2>
The Tango device/app ("client") sends its measurements via WebSockets to this vizualization server.<br>
The shapes of the colored zones are determined by a <a href="https://github.com/d3/d3-voronoi">Voronoi tesselation</a>
around each site where the Tango took data.<br>
You can pan and zoom. Works best with Chrome browser; Firefox is slow.<br>
(Note: "Smooth" is currently a hack; it just overlays diffuse semi-transparent colored circles.)<br>
<br>


<button class="button" id="reset">Reset Zoom</button>

Filter freq:
<div class="dropdown" style="display:inline-block;"
  <form>
       <select id="freqDropDown" onchange="freqChange(this)" >
          <option value="0" selected="selected"> Param EQ</option>
          <option value="1"> 62.5 Hz</option>
          <option value="2"> 125 Hz</option>
          <option value="3"> 250 Hz</option>
          <option value="4"> 500 Hz</option>
          <option value="5">1000 Hz</option>
          <option value="6">2000 Hz</option>
          <option value="7">4000 Hz</option>
      </select>
  </form>
</div>
<input type="checkbox" id="sitesToggle" >Sites
<!--<button id="sitesToggle">Toggle Sites</button>-->
<input type="checkbox" id="boundsToggle" >Bounds
<input type="checkbox" id="blurToggle">Smooth</button>
<input type="checkbox" id="gridToggle">Grid</button>

<br>
<button class="button" id="saveData">Save Data</button>
<button class="button" id="clear">Erase Data</button>
<button class="button" id="saveImage">Save Image</button>
<form id="myform" style="display:inline-block;">
    Upload Data:<input id="myfile" name="files[]" multiple="" type="file"/>
</form>
<br>

<table border="0px">   <!-- Wanted to use div & CSS instead of table, but this works!-->
  <tr>
    <td>
      <svg width="550" height="500" colorbar="50" id="figureSvg" xmlns="http://www.w3.org/2000/svg"></svg>
      <br><i>For more comprehensive (albeit not real-time) visualization options<br>(including full 3D), click "Save Data" and then use
        <a href="https://www.paraview.org/">ParaView</a> to read<br>the CSV file.
        <a target="blank" href="http://hedges.belmont.edu/~shawley/WebVizServer/ParaViewInstrunctions.html">Instructions to use ParaView for unstructured data</a>

    </td>
    <td style="vertical-align:top">
      <textarea rows="15" cols="40" style="vertical-align:top" id="notesField">Notes:
</textarea><br>
      <i>When saving images, Notes get included<br>in SVG file as metadata.</i>
    </td>
  </tr>
</table>

<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-hsv.v0.1.min.js"></script>

<script src="https://d3js.org/d3-contour.v1.min.js"></script>

<script>

  //----------------------- WebSocket Handling
  $(function () {
    var socket = io();
    $('form').submit(function(){
      socket.emit('chat message', $('#m').val());
      $('#m').val('');
      return false;
    });
    socket.on('chat message', function(msg){   // We got a message!
      //$('#messages').append($('<li>').text(msg));
      console.log("We got a Websockets message...")
      applyNewMsg(msg);
    });
  });



  //----------------------    Graph Handling



    var svg = d3.select("svg"),
        width = (+svg.attr("width") - +svg.attr("colorbar")),
        height = +svg.attr("height");

    /*var colorBar = d3.select("body")
            .append("svg")*/

    var zoom = d3.zoom()
        .scaleExtent([.5, 40])
        .translateExtent([[-100, -100], [width + 100, height + 100]])
        .on("zoom", zoomed);


    transform = d3.zoomIdentity;

    // Random data to start with
    var npoints = 3000;
    // generate a parameterized zig-zag;
    var noise_amp = 0.0;
    var x = d3.range(npoints).map(function(i) { return Math.random(); });
    var y = d3.range(npoints).map(function(i) { return Math.random(); });
    var z = d3.range(npoints).map(function(i) { return 0; });
    var worldCoords = d3.range(npoints)
        //.map(function(d,i) { return [0.5*(1+Math.cos(100*i/npoints)), i/npoints, 0]; });
        .map(function(d,i) { return [x[i], y[i], z[i]]; });

    var sites = d3.range(npoints)
        .map(function(d) { return [ worldCoords[d][0]*width, worldCoords[d][1]* height]; });


    // demo data:
    nZBins = 8;
    var dBvals = [ d3.range(npoints), d3.range(npoints), d3.range(npoints), d3.range(npoints),
                   d3.range(npoints), d3.range(npoints), d3.range(npoints), d3.range(npoints)];
   /*
   // fake room modes
   var kx = 3.14159/(width);
   var ky = 3.14159/(height);
    for (j = 0; j < nZBins; j++) {
      for (i = 0; i < npoints; i++) {
          dBvals[j][i] = (1.0 + Math.cos((j+1)*kx*sites[i][0]) * Math.cos((j+1)*ky*sites[i][1]))/2.0;
          dBvals[j][i] *= dBvals[j][i];
      }
    }
    */
    // fake two-speaker interference pattern
    var ppf = 50;    // pixels per foot
    var vs = 1130;    // feet per second
    var dist = 2*ppf;    // sources 2 feet apart
    var source1x = width/2 - dist/2;
    var source2x = width/2 + dist/2;
    var source1y = height;
    var source2y = source1y;
     for (j = 0; j < nZBins; j++) {
       var f =  32.25*Math.pow(2, j);   // different frequencies
       var lambda = vs/f * ppf;         // wavelength in pixels
       var k = 2*3.1415/lambda;         // wave number in inverse pixels
       for (i = 0; i < npoints; i++) {
           var r1 = Math.sqrt( (sites[i][0] - source1x)**2 + (sites[i][1]-source1y)**2 ); // distance in pixels
           var r2 = Math.sqrt( (sites[i][0] - source2x)**2 + (sites[i][1]-source2y)**2 );
           dBvals[j][i] = Math.cos(k*r1)/r1 + Math.cos(k*r2)/r2;
           dBvals[j][i] *= dBvals[j][i];
           dBvals[j][i] = 2*Math.log(dBvals[j][i]) + 105;
       }
     }
     //  End demo data




    /*var showSites = true;
    var showBounds = true;
    var showBlur = true;*/

    var sitesChkBox = document.getElementById('sitesToggle');
    var boundsChkBox = document.getElementById('boundsToggle');
    var blurChkBox = document.getElementById('blurToggle');
    var gridChkBox = document.getElementById('blurToggle');
    var showSites = sitesChkBox.checked;
    var showBounds = boundsChkBox.checked;
    var showBlur = blurChkBox.checked;
    var showGrid = gridChkBox.checked;

    var g = svg.append("g")
        .attr("transform", "translate(" + 0+ "," + 0 + ")");


    function getMinMaxOf2DIndex (arr, idx) { //https://stackoverflow.com/questions/23396945/getting-the-min-and-max-value-in-javascript-but-from-a-2d-array
        return {
            min: Math.min.apply(null, arr.map(function (e) { return e[idx]})),
            max: Math.max.apply(null, arr.map(function (e) { return e[idx]}))
        }
    }

    var dBIndex = document.getElementById("freqDropDown").value;
    var dB_plot = dBvals[dBIndex];


    function set_colors() {
        dBIndex = document.getElementById("freqDropDown").value;
        dB_plot = dBvals[dBIndex];
        maxHue = 310;
        dBMax = 100;
        dBMin = 40;
        /*this_dBMax = Math.max.apply(Math, dB_plot);
        this_dBMin = Math.min.apply(Math,  dB_plot);
       colors = dB_plot.map(function(q) { return q - dBMin; });
        colorMax = Math.max.apply(Math, colors);
        colorMin = Math.min.apply(Math, colors);
        colorScaleFactor = maxHue/(colorMax - colorMin);
        colors = colors.map(function(q) { return q * colorScaleFactor; });
        //console.log(" set_colors: colors = ",colors)*/
        var linearScale = d3.scaleLinear()
                            .domain([dBMin,dBMax])
                            .range([0,maxHue])
                            .clamp(true)

        colors = dB_plot.slice().map( function(d) { return linearScale(d) });
      /*  colorMax = Math.max.apply(Math, colors);
        colorMin = Math.min.apply(Math, colors);
        console.log("colorMin, colorMax = ",colorMin, colorMax,", dBMax = ",dBMax," this_dBMax = ",this_dBMax)
        */
    }
    set_colors();

    var xextents = getMinMaxOf2DIndex(sites,0);
    var yextents = getMinMaxOf2DIndex(sites,1);
    var voronoi = d3.voronoi()
        .extent([[xextents.min-1, yextents.min-1], [xextents.max + 1, yextents.max + 1]]);


    // filters and interpolation for smoothing/blur
    var filter = svg.append("defs")
        .append('filter')
          .attr('id', 'blur');
        filter.append("feGaussianBlur")
          .attr("stdDeviation", 8);

    var scale_x = d3.scaleLinear()
        .domain(d3.extent(sites, function (d) { return +d[0]; }))
        .range([0, width+1])
        .nice();
    var scale_y = d3.scaleLinear()
        .domain(d3.extent(sites, function (d) { return +d[1]; }))
        .range([0, height+1])
        .nice();
    var scale_color = d3.scaleLinear()
        .domain(d3.extent(dB_plot, function (d) { return +d; }))
        .range([d3.hsl(0, 1, 0.5), d3.hsl(310, 1, 0.5)])
        .interpolate(d3.interpolateHslLong)
        .nice();
   // end filters for smoothing/blur

  // voronoi polygons
    function add_polygons() {
       set_colors();
      //console.log("dBIndex = ",dBIndex)
      //console.log(" add_polygons: colors = ",colors)

      polygon = svg.append("g")  // global
          .attr("class", "polygons")
          .selectAll("path")
          .data(voronoi.polygons(sites))
          .enter().append("path")
          //.style("fill", function (d,i) { return scale_color(dB_plot[i]); })
          .style("fill", function (d,i) { return d3.hsl( colors[i],        1, .5); })
          .style('stroke', (showBounds ? "#000" : "none"))
          .call(redrawPolygon);
      polygon.attr("transform", transform);
    }
    add_polygons();


    function add_blurries() {   // adds a buch of rectangular blur effects all over the place
        var diagram = voronoi(sites);

        var nblurries = Math.floor(npoints/4);
        var  blurrySites = d3.range(nblurries)
                .map(function(d) { return [ Math.random()*xextents.max, Math.random()*yextents.max]; });

        //blurrySites = sites;
        var radius = 15;

        blurries = svg.append("g")
            .attr("class", "blurries")
            .selectAll("rect")
            .data(blurrySites)
            .enter().append("circle")
            .attr("cx", function (d) { return +scale_x(+d[0]); })
            .attr("cy", function (d) { return +scale_y(+d[1]); })
            .attr("r", radius)
            .style("fill", function (d) {
                 return scale_color(dB_plot[diagram.find(d[0],d[1]).index]); // color using nearest site
            })
            .style('fill-opacity', 0.3)
            .attr("filter", "url(#blur)");
        blurries.attr("transform", transform);
    }
    if (showBlur) {
      add_blurries();
    }

   //------ end smoothing

   // bunch of rectangles made up of local averages within each rectangle
   function add_contour() {
     var n = 64, m = 64;                    // grid dimensions

     /*dx = (xextents.max - xextents.min)/n;
     dy = (yextents.max - yextents.min)/m;*/
     dx = width / n;
     dy = height / m;

    var dBIndex = document.getElementById("freqDropDown").value;
     var dB_plot = dBvals[dBIndex];

     set_colors();
     var diagram = voronoi(sites);
     var triangles = diagram.triangles;

     var values = new Array(n * m);
      for (var j = 0.5, k = 0; j < m; ++j) {   // center of each cell?
        for (var i = 0.5; i < n; ++i, ++k) {
          loc = [i*dx, j*dy]
          ind = diagram.find(loc[0],loc[1],200).index; // find nearest site
           values[k] = colors[ind];  // assign color based on nearest value
        }
      }
      //console.log("values = ",values)
      grid = svg.append("g")
          .attr("class", "grid")
          .selectAll("path")
          .data(d3.contours()
          .size([n, m])
          .thresholds(d3.range(0, 310, 12))
          (values))
          .enter().append("path")
          .attr("d", d3.geoPath(d3.geoIdentity().scale(width / n)))
          .style("fill", function(d,i) { return d3.hsl( d.value, 1, .5 ); })
          //.style('fill-opacity',)
          .style("stroke","none");
   }
   function add_grid() {
     add_contour();
   }
   if (showGrid) {
      add_grid();
   }


    // show locations of data points
    function add_sites() {
        site = svg.append("g")
            .attr("class", "sites")
            .selectAll("circle")
            .data(sites)
            .enter().append("circle")
            .attr("r", 2)
            .style('fill', (showSites ? "#000" : 'none'))
            .style('stroke', (showSites ? "#FFF" : 'none'))
            .style('fill-opacity',(showSites ? 0.999 : 0))
            .style('stroke-opacity',(showSites ? 0.999 : 0))
            .call(redrawSite);
        site.attr("transform", transform);
    }

    add_sites()


    function add_colorbar() {
      set_colors();
      nstops = 10;;
      var legend = svg.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");
      for (i=0; i<nstops+1; i++) {
          legend.append("stop").attr("offset", i*(100/nstops)+"%").attr("stop-color", d3.hsl(maxHue*(nstops-i)/nstops, 1, .5)).attr("stop-opacity", 1);
      }
      colorbar = svg.append("g")
          .attr("class", "colorbar")
          .append("rect")
          .attr("x",width+8).attr("y",0)
          .attr("width", 18).attr("height", height)
	         .style("fill", "url(#gradient)" );

      var dBscale = d3.scaleLinear().range([height, 0]).domain([dBMin, dBMax]);

      g = svg.append("g")
      .attr("transform", "translate(" + 525 + ",0)")
      .attr("class", "axis")
      .call(d3.axisRight(dBscale).ticks(12, "s"));

    }
    add_colorbar();


    function redrawPolygon(polygon) {
      polygon
          .attr("d", function(d) { return d ? "M" + d.join("L") + "Z" : null; });
    }
    function redrawSite(site) {
        site
            .attr("cx", function(d) { return d[0]; })
            .attr("cy", function(d) { return d[1]; });
    }



    // Buttons
    d3.select("#reset").on("click", reset_zoom);
    d3.select("#clear").on("click", clear_data);
    d3.select("#saveData").on("click", save_data);
    d3.select("#saveImage").on("click", save_image)
    d3.select("#sitesToggle").on("click", function (d) {
        showSites = !showSites;
        if (showSites) {
          add_sites();
        } else {
          svg.selectAll("g.sites").remove();
        }
    });
    d3.select("#boundsToggle").on("click", function (d) {
        showBounds = !showBounds;
        svg.selectAll("g.polygons")
        .selectAll("path")
        .style('stroke', (showBounds ? "#000" : 'none'))
    });

    d3.select("#blurToggle").on("click", function (d) {
      showBlur = !showBlur;
      if (showBlur) {             // removing blurries speeds up code & shrinks file size
        add_blurries();
      } else {
        svg.selectAll("g.blurries").remove();
      }
      if (showSites) {  // keep sites on top. could go & indivudally move to top, or just regenerate
        svg.selectAll("g.sites").remove();  // destroy & remake
        add_sites();
      }
    });
    d3.select("#gridToggle").on("click", function (d) {
      showGrid  = !showGrid;
      if (showGrid) {
        add_grid();
      } else {
        svg.selectAll("g.grid").remove();
      }
    });

    // Zooming
    svg.call(zoom);

    // handle the Shift key during mouse movements (for rotation)
    shiftDown = false;
    window.onmousemove = function (e) {
      if (!e) e = window.event;
      shiftDown = false;
      if (e.shiftKey) {shiftDown = true}
    }

    rotateAngle = 0;
    function zoomed() {
        transform = d3.event.transform;
        //console.log("transform = ",d3.transform(transform))
        if (shiftDown) {
            rotateAngle +=  d3.event.transform.y/20;
            //fullTransform = d3.transform;
            //console.log("fullTransform = ",fullTransform);
            new_transform ="translate(" + transform.x + ", " + transform.y + ")rotate("+rotateAngle+")";
            console.log("shift key is down. new_transform = ",new_transform)

            effect_zoom(new_transform)
        } else {
            effect_zoom(transform);
        }

    }
    function effect_zoom(transform) {
        if (showSites) {
          site.attr("transform", transform);
        }
        polygon.attr("transform", transform);
        if (showBlur) {
          blurries.attr("transform", transform);
        }
        if (showGrid) {
          grid.attr("transform", transform);
        }
    }

    function reset_zoom() {
      svg.transition()
          .duration(700)
          .call(zoom.transform, d3.zoomIdentity);
      transform = d3.zoomIdentity;
    }
    function clear_data() {
      svg.selectAll("g.polygons").remove(); // delete old polygons
      svg.selectAll("g.sites").remove(); // delete old sites
      npoints = 0;
    }


    // stackoverflow
    function download_text(filename, text) {
      var element = document.createElement('a');
      element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
      element.setAttribute('download', filename);

      element.style.display = 'none';
      document.body.appendChild(element);

      element.click();

      document.body.removeChild(element);
      //console.log("download_text:")
    }

    function save_data() {
      var text = "x,y,z,dB,dB0,dB1,dB2,dB3,dB4,dB5,dB6\n";
      //console.log("x = ",x)
      for (p=0; p < npoints; p++) {
        //text += String(worldCoords[p][0])+","+String(worldCoords[p][1])+","+String(worldCoords[p][2]);
        text += String(x[p])+","+String(y[p])+","+String(z[p]);
        for (j=0; j < nZBins; j++) {
           text += ","+String(dBvals[j][p])
        }
        text += "\n";
      }
      download_text("TangoData.csv",text)
    }

    function save_image() { //https://stackoverflow.com/questions/23218174/how-do-i-save-export-an-svg-file-after-creating-an-svg-with-d3-js-ie-safari-an
      var note = "\n"+$("#notesField")[0].value+"\n";  // \n's make it easier to read IMHO
      svg.attr("description",note);   // not sure if this is legal SVG, but works so far
      var svgData = $("#figureSvg")[0].outerHTML;
      var svgBlob = new Blob([svgData], {type:"image/svg+xml;charset=utf-8"});
      var svgUrl = URL.createObjectURL(svgBlob);
      var downloadLink = document.createElement("a");
      downloadLink.href = svgUrl;
      downloadLink.download = "TangoImage.svg";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }


    // 'Uploading' a file  (really just reading it locally into the  browser)
    document.forms['myform'].elements['myfile'].onchange = function(evt) {
    if(!window.FileReader) return; // Browser is not compatible
    var reader = new FileReader();

    reader.onload = function(evt) {
        if(evt.target.readyState != 2) return;
        if(evt.target.error) {
            alert('Error while reading file');
            return;
        }

        filecontent = evt.target.result;
        var text = filecontent;
        //console.log("text = ",text)
        applyNewMsg(text);
        //document.forms['myform'].elements['text'].value = evt.target.result;
    };

    reader.readAsText(evt.target.files[0]);
};




    // Freq Change
    function freqChange(option) {
        //console.log(option.value);
        //basefreq = 250.0;
        //freq = option.value*1.0
        freqBin = option.value;
        var dBIndex = document.getElementById("freqDropDown").value;
        dB_plot = dBvals[dBIndex];

      /*  dBMax = Math.max.apply(Math, dB_plot);
        dBMin = Math.min.apply(Math,  dB_plot);
        colors = dB_plot.map(function(q) { return q - dBMin; });
        colorMax = Math.max.apply(Math, colors);
        colorMin = Math.min.apply(Math, colors);
        intendedColorRange = 310;
        colorScaleFactor = intendedColorRange/(colorMax - colorMin);
        colors = colors.map(function(q) { return q * colorScaleFactor; });*/
        set_colors();
        //colorMax = Math.max.apply(Math, colors);

        svg.selectAll("g.polygons")
          .selectAll("path")
          .style('fill', function(d,i){ return d3.hsl( colors[i],        1, .5); })
          //.style("fill", function (d,i) { return scale_color(dB_plot[i]); })
            .call(redrawPolygon);

        if (showBlur) {   // easer to just regenerate them
          svg.selectAll("g.blurries").remove();
          add_blurries();
          if (showSites) {  // keep sites on top. could go & indivudally move to top, or just regenerate
            svg.selectAll("g.sites").remove();  // destroy & remake
            add_sites();
          }
        }
        if (showGrid) {
          svg.selectAll("g.grid").remove();
          add_grid();
          if (showSites) {  // keep sites on top. could go & indivudally move to top, or just regenerate
            svg.selectAll("g.sites").remove();  // destroy & remake
            add_sites();
          }
        }
    }



    // When new socket messages come in
    function parseMsg(msg) {
        // https://stackoverflow.com/questions/41154231/d3-how-do-i-parse-a-csv-string-into-an-object-where-keys-are-column-names-and-v
        var data = d3.csvParse(msg);
        var headers = d3.keys(data[0]);
        console.log("headers = ",headers)

        var myObject = {};
        headers.forEach(function(d) {
            myObject[d] = [];
        });
        data.forEach(function(d) {
            for (var key in d) {
                myObject[key].push(d[key]);
            }
        });
        return myObject;
    }

    function applyNewMsg(msg) {
        var parsed = parseMsg(msg);
        x = parsed.x.map(Number);
        y = parsed.y.map(Number);
        z = parsed.z.map(Number);
        dBvals[0] = parsed.dB.map(Number);    // Fullband-averaged dB value
        dBvals[1] = parsed.dB0.map(Number);  // dB in lowest freq band (63Hz)
        dBvals[2] = parsed.dB1.map(Number);  // dB in next freq band (125Hz)
        dBvals[3] = parsed.dB2.map(Number);  // dB in next freq band (250Hz)
        dBvals[4] = parsed.dB3.map(Number);  // dB in next freq band (500Hz)
        dBvals[5] = parsed.dB4.map(Number);  // dB in next freq band (1kHz)
        dBvals[6] = parsed.dB5.map(Number);  // dB in next freq band (2kHz)
        dBvals[7] = parsed.dB6.map(Number);  // dB in next freq band (4kHz)
        updateData(x,y,z,dBvals);
    }


    function updateData(x,y,z,dBVals) {
        npoints = x.length;
        worldCoords = d3.range(npoints)
        for (p=0; p < npoints; p++) {
          worldCoords[p][0] = x[p];
          worldCoords[p][1] = y[p];
          worldCoords[p][2] = z[p];
        }

        //scale world coordinates to screen coordinates
        xMin = Math.min.apply(Math, x);
        xMax = Math.max.apply(Math, x);
        yMin = Math.min.apply(Math, y);
        yMax = Math.max.apply(Math, y);

        var xScale = width / (xMax-xMin);
        var yScale = height / (yMax-yMin);
        var uniScale = xScale;   // use the same (smaller) scale in x & y
        if (yScale < xScale) {
          uniScale = yScale;
        }
        var xScreen = x.map(function(q) { return (q - xMin) * uniScale; });
        var yScreen = y.map(function(q) { return (q - yMin) * uniScale; });
        sites = d3.range(npoints)
         .map(function(d,i) { return [(xScreen[i]), (yScreen[i])]; });


        xextents = getMinMaxOf2DIndex(sites,0);
        yextents = getMinMaxOf2DIndex(sites,1);
        //console.log("xextents.min = ",xextents.min)
        voronoi = d3.voronoi()
            .extent([[xextents.min-1, yextents.min-1], [xextents.max + 1, yextents.max + 1]]);

        var dBIndex = document.getElementById("freqDropDown").value;
        dB_plot = dBvals[dBIndex];

        svg.selectAll("g.polygons").remove(); // delete old polygons
        svg.selectAll("g.blurries").remove(); // delete all blurry circles
        svg.selectAll("g.sites").remove();  // delete old sites
        add_polygons();
        if (showBlur) {
           add_blurries();
        }
        add_sites();

        freqChange(document.getElementById("freqDropDown"));

    }

    // from http://techslides.com/demos/d3/svg-to-image-1.html


//svg.selectAll("g").attr("transform", "rotate(-15)");
// svg.selectAll("g.sites").attr("transform", "rotate(-15)");
 //svg.selectAll("g.blurries").attr("transform", "rotate(-15)");

</script>

</body>
</html>
